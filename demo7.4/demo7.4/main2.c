#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//条件操作符(三目操作符)
//int main()
//{
//	int a = 0;
//	int b = 0;
//	if (a > 5)
//		b = 3;
//	else
//		b = -3;
//	b = (a > 5 ? 3 : -3);
//	int max = (a > b ? a : b);
//	return 0;
//}

//表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
//一般就是int的字节长度，同时也是CPU的通用寄存器的长度。

//因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。

//通用CPU（general - purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令
//中可能有这种字节相加指令）。
//所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。

//表达式求值
// 
//隐式类型转换
//1、整型提升
//int main()
//{
//	char a = 3;//(默认为有符号的char)
//	//00000000000000000000000000000011(int 四个字节)
//	//00000011 a(char 一个字节(从低位开始截断8位))
//
//	char b = 127;//(默认为有符号的char)
//	//00000000000000000000000001111111
//	//01111111 b(char 一个字节(从低位开始截断8位))
//
//	char c = a + b;//(默认为有符号的char)
//	//a和b如何相加
//	//00000011 a 
//	//01111111 b
//	//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//	//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，
//	//这种转换称为整型提升。
//	//整形提升是按照变量的数据类型的符号位来提升的
//	//00000000000000000000000000000011 a(char只有一个字节,其余为用符号位填充为四个字节)
//	//00000000000000000000000001111111 b(char只有一个字节,其余为用符号位填充为四个字节)
//	//相加
//	//00000000000000000000000010000010 a + b
//
//	//此时c为char,只需要8位,从地位截断
//	//10000010 c
//	printf("%d\n", c);
//	//此时打印的是整型(%d),需要整型提升,此时符号位为1,其余为填充为1
//	//11111111111111111111111110000010 c 补码
//	//11111111111111111111111110000001 反码
//	//10000000000000000000000001111110  原码
//	//-126
//	return 0;
//}

//int main()
//{
//	char a = 0xb6; 
//	//10110110 a
//
//	short b = 0xb600;
//	//1011011000000000(4个16进制数,转换为16二进制数,short两个字节,发生截断,从低位截断)
//	//00000000 b
//
//	int c = 0xb6000000;
//	//1011011000000000000000000000000(8个16进制数,转换为32二进制数,int四个字节,不发生截断)
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}

//int main()
//{
//	char c = 1;
//	//%u是输入输出格式说明符,表示按unsigned int格式输入或输出数据
//	printf("%u\n",sizeof(c));  //1
//	printf("%u\n", sizeof(+c));//4
//	printf("%u\n", sizeof(!c));//1
//	return 0;
//}

//2、算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
//型，否则操作就无法进行。下面的层次体系称为寻常算术转换。
//如果某个操作数的类型在上面这个列表中排名较低，
//那么首先要转换为另外一个操作数的类型后执行运算。
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//char
//复杂表达式的求值有三个影响的因素。
//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序。
//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。
//操作符优先级
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = b + a * 3;
//	printf("%d\n", c); //50
//	return 0;
//}


//注释：代码1在计算的时候，由于*比+的优先级高，只能保证，*的计算是比+早，
//但是优先级并不能决定第三个* 比第一个 + 早执行
//int main()
//{
//	int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6;
//	//有问题的表达式
//	//因为该表达式的计算路径不唯一,所以该表达式是问题表达式
//	int var = a * b + c * d + e * f;
//	printf("%d\n",var);
//	return 0;
//}


//操作符的优先级只能决定自减--的运算在+的运算的前面，但是我们并没有办法得
//知,+ 操作符的左操作数的获取在右操作数之前还是之后求值，
//所以结果是不可预测的，是有歧义的
//问题表达式
//int main()
//{
//	int c = 2;
//	c + --c;
//	printf("%d\n", c); //1
//	return 0;
//}

//问题表达式
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);
//	return 0;
//}

int fun()
{
	static int count = 1;
	return ++count;
}
//问题表达式
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();
//	printf("%d\n", answer);//输出多少？
//	return 0;
//}


//问题表达式
//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);
//	printf("%d\n", ret);//12
//	printf("%d\n", i);  //4
//	return 0;
//}


